<!DOCTYPE html>
 <html>
    <head>
    <!-- #ice{fullWidth} -->
    <title>Freixenet Vinbox</title>
    <meta name="viewport" content="target-densitydpi=device-dpi, width=320" />
    <style>
        html, body {
            margin:0px;
            padding:0px;
                height: 100%;
        }
        </style>
   <body style="width:320px">
            <!--<AdWineBox>-->
            <!-- Animated Ads, copyright Adssets AB, 2012 -->
            <script src="js/three.min.js"></script>
            <script src="js/CSS3DRenderer.js"></script>
            <script src="js/TrackballControls.js"></script>
            <script src="js/OBJLoader.js"></script>
            <script>
                /**<AdScript>**/
                var p212201IDLE_SPIN_INTERVAL = 4000;
                
                var P_212201_Swipe = 'http://pliing.se/PliingAd/Event?id=21220100&userAdId=**userAdId&callback=p212201Resp';
                var P_212201_NoOfImages=8;
                var p212201LoadedImages=0;
                var p212201SwipeArea;
                var p212201Cube;
                var p212201StartX=0;
                var p212201StartY=0;
                var p212201EndX=0;
                var p212201EndY=0;
                var p212201RotX;
                var p212201RotTimer;
                var p212201SpinTimer;
                var p212201RotDir=1;
                var p212201Swiped=false;
                var p212201RotAng=-360;
                var p212201Side = [];
                var p212201Script;
                var p212201isNotWebkit = navigator.userAgent.toLowerCase().indexOf("android 2.") > -1; 
                var p212201isAndroid = navigator.userAgent.toLowerCase().indexOf("android") > -1;
                var p212201ActImg;
                
                var p212201MaxGyroTilt = 25;
                
                //Added by Joel
                var model;
                
                var controls;
                var scene;
                var camera;
                var renderer;
                
                var scene2, renderer2;
                
                function p212201ImgLoaded () {
                    if (p212201LoadedImages==0) {
                        var node = document.getElementById("p212201_ad_container");
                        for (var i = 0; i < 4; i++) {
                            node = node.parentNode;
                            if (node == null)
                                break;
                            else if (node.className == "abAdArea") {
                                node.style.overflow = "visible";
                                node.style.display = "block";
                                break;
                            }
                        }
                        if (p212201isNotWebkit) {
                            document.getElementById("p212201_img_swipe").style.webkitTransform="translate3d(0px,0px,0px)";
                            document.getElementById("p212201_cube_area").style.webkitTransform="translate3d(0px,0px,0px)";
                            document.getElementById("p212201_cube_area").style.overflow="hidden";
                            for (var i=0;i<4;i++) {
                                p212201Side[i] = document.getElementById("p212201_side_"+(i+1));
                                if (i==0)
                                    p212201Side[i].style.opacity="1.0";
                                else
                                    p212201Side[i].style.opacity="0.0";
                                if (i==3)
                                    p212201Side[i].style.webkitTransform="translate3d(-300px,0px,0px)";
                                else
                                    p212201Side[i].style.webkitTransform="translate3d("+(300*i)+"px,0px,0px)";
                            }
                        }
                    }
                    p212201LoadedImages++;
                    if (p212201LoadedImages == (P_212201_NoOfImages)) {
                        p212201InitBanner();
                    }
                }
                function p212201InitBanner () {
                    if (p212201isNotWebkit) {
                        window.scrollBy(0,1);
                        for (var i=0;i<4;i++)
                            p212201Side[i].style.webkitTransition="all 0.5s ease-out";
                    }
                    
                    p212201SwipeArea = document.getElementById("p212201_revolve_area");
                    p212201Cube = document.getElementById("p212201_cube");
                    p212201RotX = document.getElementById("p212201_rot_x");
                    p212201AddListener();
                    p212201Rotate();
                    document.getElementById("p212201_img_swipe").style.visibility="visible";
                }
                function p212201Rotate () {
                    
                    p212201ActImg = 4;
                    
                    
                    if (p212201isNotWebkit) {
                        p212201ARot(1);
                        window.setTimeout(function () {p212201ARot(1)}, 400);
                        window.setTimeout(function () {p212201ARot(1)}, 800);
                        window.setTimeout(function () {p212201ARot(1)}, 1200);
                    }
                    else {
                        p212201RotAng=p212201ActImg*(-90);               
                        p212201Cube.style.webkitTransform="rotateY("+p212201RotAng+"deg)";
                        p212201RotX.style.webkitTransform="rotateX(-12deg)";
                    }
                }
                function p212201ARot (rot) {
                    var i = (p212201ActImg+rot)%4;
                    p212201ActImg = i;
                    p212201Side[i].style.opacity="1.0";
                    p212201Side[i].style.webkitTransform="translate(0px,0px)";
                    p212201Side[(i+1)%4].style.opacity="0.0";
                    p212201Side[(i+1)%4].style.webkitTransform="translate(300px,0px)";
                    p212201Side[(i+2)%4].style.opacity="0.0";
                    p212201Side[(i+2)%4].style.webkitTransform="translate(600px,0px)";
                    p212201Side[(i+3)%4].style.opacity="0.0";
                    p212201Side[(i+3)%4].style.webkitTransform="translate(-300px,0px)";
                }
                function p212201IdleRot(){
                    p212201RotDir=(p212201RotDir+1)%4;
                    var i,j;
                    switch (p212201RotDir) {
                        case 0:
                            i=0;j=1;break;
                        case 1:
                            i=-1;j=0;break;
                        case 2:
                            i=0;j=-1;break;
                        case 3:
                            i=1;j=0;break;
                    }
                    p212201RotX.style.webkitTransform="rotateX("+(i*15)+"deg) rotateY("+(j*15)+"deg)";
                }
                
                function p212201IdleSpin(){
                    p212201RotAng=(p212201RotAng + 180);
                    p212201RotAng =(Math.floor(p212201RotAng/180) * 180);
                    p212201Cube.style.webkitTransform="rotateY("+p212201RotAng+"deg)";
                }
                
                function p212201AddListener()
                {
                    p212201SwipeArea.addEventListener("touchstart", p212201TouchStart, false);
                    p212201SwipeArea.addEventListener("touchmove", p212201TouchMove, false);
                    p212201SwipeArea.addEventListener("touchend", p212201TouchEnd, false);
                    if (window.DeviceOrientationEvent){
                        window.addEventListener("deviceorientation", p212201DeviceOrientationHandler, false);
                    }
                }
                function p212201RemoveListener(e)
                {
                    e.removeEventListener("touchstart", p212201TouchStart, false);
                    e.removeEventListener("touchmove", p212201TouchMove, false);
                    e.removeEventListener("touchend", p212201TouchEnd, false);
                }
                function p212201TouchStart(e)
                {
                    p212201StartX = e.touches[0].pageX;
                    p212201StartY = e.touches[0].pageY;
                    p212201EndX = 0;
                    p212201EndY = 0;
                    if (window.DeviceOrientationEvent){
                        window.removeEventListener("deviceorientation", p212201DeviceOrientationHandler, false);
                    }
                } 
                function p212201TouchMove(e)
                {
                    if (Math.abs(e.touches[0].pageX - p212201StartX) > Math.abs(e.touches[0].pageY - p212201StartY)) {
                        e.preventDefault();
                        p212201EndX = e.touches[0].pageX - p212201StartX;
                        p212201EndY = p212201StartY - e.touches[0].pageY;
                        if (p212201isNotWebkit) {
                            var i = p212201ActImg;
                            p212201Side[i].style.opacity=1-(Math.abs(p212201EndX)/300);
                            p212201Side[i].style.webkitTransform="translate("+p212201EndX+"px,0px)";
                            if (p212201EndX > 0) {
                                p212201Side[(i+3)%4].style.opacity=p212201EndX/300;
                                p212201Side[(i+3)%4].style.webkitTransform="translate("+(p212201EndX-300)+"px,0px)";
                            }
                            else {
                                p212201Side[(i+1)%4].style.opacity=Math.abs(p212201EndX)/300;
                                p212201Side[(i+1)%4].style.webkitTransform="translate("+(300+p212201EndX)+"px,0px)";
                            }
                        }
                        else {
                            p212201Cube.style.webkitTransform="rotateY("+(p212201RotAng+p212201EndX)+"deg)";
                            p212201RotX.style.webkitTransform="rotateX("+p212201EndY+"deg)";
                        }
                    }
                }
                
                function p212201TouchEnd(e)
                {
                    var next=0;
                    if (Math.abs(p212201EndX)>45) {
                        document.getElementById("p212201_img_swipe").style.visibility="hidden";
                        document.getElementById("p212201_img_swipe").style.webkitTransform="translate3d(0px,0px,-150px)";
                        p212201RegSwipe ();
                        if (p212201isNotWebkit) {
                            if (p212201EndX>0) 
                                next=3;
                            else
                                next=1;
                        }
                        else {
                            if (p212201EndX>=0) 
                                p212201RotAng=(p212201RotAng + (90 * Math.round((p212201EndX/90))));
                            else if (p212201EndX<0)
                                p212201RotAng=(p212201RotAng + (90 * Math.round((p212201EndX/90))));
                        }
                    }
                    if (p212201isNotWebkit)
                        p212201ARot(next);
                    else {
                        p212201Cube.style.webkitTransform="rotateY("+p212201RotAng+"deg)";
                    }
                    
                    if (window.DeviceOrientationEvent){
                        window.addEventListener("deviceorientation", p212201DeviceOrientationHandler, false);
                    }
                }
                function p212201RegSwipe () {
                    if (!p212201Swiped) {
                        p212201Swiped=true;
                        p212201RegEvent (P_212201_Swipe);
                    }
                }
                function p212201RegEvent (src) {
                    p212201Script= document.createElement('script');
                    p212201Script.type= 'text/javascript';
                    p212201Script.src= src;
                    document.getElementsByTagName('head')[0].appendChild(p212201Script);
                }
                function p212201Resp(xmlData) {
                    document.getElementsByTagName('head')[0].removeChild(p212201Script);
                }
                
                function p212201LoadIcal(){
                    window.open("http://pliing.se/img12/box/new/boxvinnew.ics", "_parent");
                    p212201RegEvent(P_212201_iCal);
                }
                
                function p212201LoadLink(){
                    //window.open("http://pliing.se/PliingAd/ExtLink?id=21220110&userAdId=**userAdId","_blank");
                }
                
                function p212201DeviceOrientationHandler(gyroData){
                    var p212201Alpha = gyroData.alpha;
                    var p212201Beta = gyroData.beta;
                    var p212201Gamma = gyroData.gamma;
                    if(typeof p212201OAlpha === 'undefined'){
                        p212201OAlpha = p212201Alpha;
                        p212201OBeta = p212201Beta;
                        p212201OGamma = p212201Gamma;
                    }
                    
                    var gyroAngX, gyroAngY;
                    if(p212201Gamma >= 90){
                        gyroAngX = p212201CorrectInterval(p212201OBeta + (90 - p212201Beta), p212201MaxGyroTilt);
                        gyroAngY = (p212201RotAng + p212201CorrectInterval((180 - p212201Gamma - p212201OGamma), p212201MaxGyroTilt));
                    } else {
                        gyroAngX = p212201CorrectInterval((p212201Beta - p212201OBeta), p212201MaxGyroTilt); 
                        gyroAngY = (p212201RotAng - p212201CorrectInterval((p212201Gamma - p212201OGamma), p212201MaxGyroTilt));
                    }
                    p212201Cube.style.webkitTransform = "rotateY(" + gyroAngY + "deg)"; 
                    p212201RotX.style.webkitTransform = "rotateX(" + gyroAngX + "deg) ";
                }
                
                function p212201CorrectInterval(val, max){
                    if(val > max){
                        val = max;
                    } else if(val < -max){
                        val = -max;
                    }
                    return val;
                }
                
                //Model loader stuff
                function loadModel() {
                    var objLoader = new THREE.OBJLoader();
                    objLoader.load("/WineBottleProject/Model/Vinflaska/broken_normals.obj", modelLoaded);
                    //objLoader.load("/WineBottleProject/Model/Vinflaska/lowpoly_obj.obj", modelLoaded);
                };
                
                var winWidth = 300;
                var winHeight = 600;
                
                var texture = new THREE.Texture();

                var loader = new THREE.ImageLoader(  );
                loader.load( "/WineBottleProject/Model/Vinflaska/vinflaska_textur.jpg", function ( image ) {

                        texture.image = image;
                        texture.needsUpdate = true;

                } );
                
                var modelLoaded = function( object ) {
                    model = object;
                    model.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.material.map = texture;
                        }
                    } );
                    
                    convertModel();
                };
                
                function convertModel() {
                    
                    scene = new THREE.Scene();
                    camera = new THREE.PerspectiveCamera( 45, winWidth / winHeight, 1, 10000 );
                    camera.position.set( 0, 500, 2000 );
                    
                    controls = new THREE.TrackballControls( camera );
                    //model.children[0].scale = 100;
                    scene.add( new THREE.WireframeHelper( model.children[0] ) );
                    
                    var faces = model.children[0].geometry.faces;
                    
                    var loopLength = faces.length;
                    var scale = 100;
                    
                    var padding = 0;
                    
                    var vertices = [];
                    for (var i = 0; i < model.children[0].geometry.vertices.length; i++) {
                        //Copying value instead of reference to not change original values later
                        vertices[i] = new THREE.Vector3(model.children[0].geometry.vertices[i].x, 
                                                        model.children[0].geometry.vertices[i].y, 
                                                        model.children[0].geometry.vertices[i].z);
                        
                    }
                    
                    var centreOfFaces = [];
                    var centre;
                    var aTri, bTri, cTri;
                    
                    var quaternion = new THREE.Quaternion();
                    var quaternion2 = new THREE.Quaternion();
                    var sizeOfFaces = [];
                    var aCoord = new THREE.Vector2(), bCoord = new THREE.Vector2(), cCoord = new THREE.Vector2();
                    
                    var image = new Image();
                    image.src = "/WineBottleProject/Model/Vinflaska/vinflaska_textur.jpg";
                    
                    ////////////////////////////////////////////////////////
                    //           ERROR PROBABLY SOMEWHERE HERE            //
                    ////////////////////////////////////////////////////////
                    
                    image.onload = function() {
                    for (var i = 0; i < loopLength; i++) {
                        var picSize = new THREE.Vector2(image.width, image.height);
                        
                        var aTri = new THREE.Vector3(vertices[faces[i].a].x, vertices[faces[i].a].y, vertices[faces[i].a].z);
                        var bTri = new THREE.Vector3(vertices[faces[i].b].x, vertices[faces[i].b].y, vertices[faces[i].b].z);
                        var cTri = new THREE.Vector3(vertices[faces[i].c].x, vertices[faces[i].c].y, vertices[faces[i].c].z);
                        /*
                        var triangle = 55;
                        //Wireframe test
                        if(i==triangle)
                        {
                            var from1 = new THREE.Vector3(aTri.x, aTri.y, aTri.z);
                            var to1 = new THREE.Vector3(bTri.x, bTri.y, bTri.z);
                            var dir1 = new THREE.Vector3().subVectors(to1, from1);
                            var frodir1 = new THREE.Vector3().addVectors(from1, dir1);
                            scene.add( new THREE.ArrowHelper(dir1.clone().normalize(), from1, dir1.length(), 0xFF0000));
                            console.log("1) from: "+from1.x+", "+from1.y+", "+from1.z);
                            console.log("1) to: "+to1.x+", "+to1.y+", "+to1.z);
                            console.log("1) dir: "+dir1.x+", "+dir1.y+", "+dir1.z);
                            console.log("1) from+dir: "+frodir1.x+", "+frodir1.y+", "+frodir1.z);
                            console.log("1) length: "+dir1.length());
                            console.log("1) color: RED");
                            console.log("-------------------------------------------------------------------");

                            var from2 = new THREE.Vector3(bTri.x, bTri.y, bTri.z);
                            var to2 = new THREE.Vector3(cTri.x, cTri.y, cTri.z);
                            var dir2 = new THREE.Vector3().subVectors(to2, from2);
                            var frodir2 = new THREE.Vector3().addVectors(from2, dir2);
                            scene.add( new THREE.ArrowHelper(dir2.clone().normalize(), from2, dir2.length(), 0x00FF00));
                            console.log("2) from: "+from2.x+", "+from2.y+", "+from2.z);
                            console.log("2) to: "+to2.x+", "+to2.y+", "+to2.z);
                            console.log("2) dir: "+dir2.x+", "+dir2.y+", "+dir2.z);
                            console.log("1) from+dir: "+frodir2.x+", "+frodir2.y+", "+frodir2.z);
                            console.log("2) length: "+dir2.length());
                            console.log("2) color: GREEN");
                            console.log("-------------------------------------------------------------------");

                            var from3 = new THREE.Vector3(cTri.x, cTri.y, cTri.z);
                            var to3 = new THREE.Vector3(aTri.x, aTri.y, aTri.z);
                            var dir3 = new THREE.Vector3().subVectors(to3, from3);
                            var frodir3 = new THREE.Vector3().addVectors(from3, dir3);
                            scene.add( new THREE.ArrowHelper(dir3.clone().normalize(), from3, dir3.length(), 0x0000FF));
                            console.log("3) from: "+from3.x+", "+from3.y+", "+from3.z);
                            console.log("3) to: "+to3.x+", "+to3.y+", "+to3.z);
                            console.log("3) dir: "+dir3.x+", "+dir3.y+", "+dir3.z);
                            console.log("1) from+dir: "+frodir3.x+", "+frodir3.y+", "+frodir3.z);
                            console.log("3) length: "+dir3.length());
                            console.log("3) color: BLUE");
                            console.log("-------------------------------------------------------------------");
                        }*/
                        //var centre2 = ((aTri.clone().add(bTri.clone().add(cTri))).divideScalar(3)).multiplyScalar(scale);
                        
                        //This calculates the centre of the triangles bounding box
                        // There be problem here somewhere...
                        /*
                        var xMax = Math.max(aTri.x, bTri.x, cTri.x);
                        var xMin = Math.min(aTri.x, bTri.x, cTri.x);
                        var yMax = Math.max(aTri.y, bTri.y, cTri.y);
                        var yMin = Math.min(aTri.y, bTri.y, cTri.y);
                        var zMax = Math.max(aTri.z, bTri.z, cTri.z);
                        var zMin = Math.min(aTri.z, bTri.z, cTri.z);
                        
                        var centre = new THREE.Vector3(((xMax+xMin)/2)*scale, ((yMax+yMin)/2)*scale, ((zMax+zMin)/2)*scale);
            */
                        //centreOfFaces.push(centre);
                        //Normal arrows
                        //scene.add( new THREE.ArrowHelper(new THREE.Vector3(0,0,0), centre, 1, 0x884400));
                        
                        
                        
                        ////////////////////////////////////////////////////////
                        //                  NORMALS ARE FINE                  //
                        ////////////////////////////////////////////////////////
                        
                        
                        // Getting rotation of all faces
                    
                        var norm = new THREE.Vector3(faces[i].normal.x, faces[i].normal.y, faces[i].normal.z);
                        
                        norm.normalize();
                        var tepm = new THREE.Vector3(0,0,1);
                        tepm.normalize();
                        var rotaxis = new THREE.Vector3(0,1,0);
                        var up = new THREE.Vector3(faces[i].normal.x, faces[i].normal.y, faces[i].normal.z);
                        
                        rotaxis.cross(up);
                        //scene.add( new THREE.ArrowHelper(up, centre2, 1, 0xFF9900));
                        up.applyAxisAngle(rotaxis.normalize(), -Math.PI/2);
                        
                        quaternion = quaternion.setFromUnitVectors(norm, tepm);
                        quaternion2 = quaternion2.setFromUnitVectors(tepm, norm);
                        //tepm.applyQuaternion(quaternion2);
                        //scene.add( new THREE.ArrowHelper(up, centre2, 1, 0xFFFF00));
                        //scene.add( new THREE.ArrowHelper(rotaxis, centre2, 1, 0x000000));
                        // Calculating size of faces
                        //Rotate the face to get a uniform starting point
                        
                        vertices[faces[i].a].applyQuaternion(quaternion);
                        vertices[faces[i].b].applyQuaternion(quaternion);
                        vertices[faces[i].c].applyQuaternion(quaternion);
                        up.applyQuaternion(quaternion);
                        
                        var angle = up.angleTo(new THREE.Vector3(0,1,0));
                        var inWards = new THREE.Vector3(0,0,1);
                        if(up.x < 0)
                            angle = -angle;
                        vertices[faces[i].a].applyAxisAngle(inWards, angle);
                        vertices[faces[i].b].applyAxisAngle(inWards, angle);
                        vertices[faces[i].c].applyAxisAngle(inWards, angle);
                        
                        
                        
                        var aTri = new THREE.Vector3(vertices[faces[i].a].x, vertices[faces[i].a].y, vertices[faces[i].a].z);
                        var bTri = new THREE.Vector3(vertices[faces[i].b].x, vertices[faces[i].b].y, vertices[faces[i].b].z);
                        var cTri = new THREE.Vector3(vertices[faces[i].c].x, vertices[faces[i].c].y, vertices[faces[i].c].z);
                        /*
                        var centre2 = ((aTri.clone().add(bTri.clone().add(cTri))).divideScalar(3)).multiplyScalar(scale);
                        scene.add( new THREE.ArrowHelper(up, centre2, 1, 0xAA00AA));
                         
                        up.applyAxisAngle(inWards, angle);
                        //Wireframe test
                        //if(i==triangle)
                        {
                            //Up arrow
                            //console.log("upAngle: " + angle);
                            scene.add( new THREE.ArrowHelper(up, centre2, 1, 0xFFFF00));
                            scene.add( new THREE.ArrowHelper(new THREE.Vector3(0,1,0), centre2, 1, 0x00AAAA));
                            
                            //Triangle
                            var from1 = new THREE.Vector3(aTri.x, aTri.y, aTri.z);
                            var to1 = new THREE.Vector3(bTri.x, bTri.y, bTri.z);
                            var dir1 = new THREE.Vector3().subVectors(to1, from1);
                            var frodir1 = new THREE.Vector3().addVectors(from1, dir1);
                            scene.add( new THREE.ArrowHelper(dir1.clone().normalize(), from1, dir1.length(), 0xFF0000));
                            
                            var from2 = new THREE.Vector3(bTri.x, bTri.y, bTri.z);
                            var to2 = new THREE.Vector3(cTri.x, cTri.y, cTri.z);
                            var dir2 = new THREE.Vector3().subVectors(to2, from2);
                            var frodir2 = new THREE.Vector3().addVectors(from2, dir2);
                            scene.add( new THREE.ArrowHelper(dir2.clone().normalize(), from2, dir2.length(), 0x00FF00));

                            var from3 = new THREE.Vector3(cTri.x, cTri.y, cTri.z);
                            var to3 = new THREE.Vector3(aTri.x, aTri.y, aTri.z);
                            var dir3 = new THREE.Vector3().subVectors(to3, from3);
                            var frodir3 = new THREE.Vector3().addVectors(from3, dir3);
                            scene.add( new THREE.ArrowHelper(dir3.clone().normalize(), from3, dir3.length(), 0x0000FF));
                
                        }
                        */
                       
                        var xMax = Math.max(aTri.x, bTri.x, cTri.x);
                        var xMin = Math.min(aTri.x, bTri.x, cTri.x);
                        var yMax = Math.max(aTri.y, bTri.y, cTri.y);
                        var yMin = Math.min(aTri.y, bTri.y, cTri.y);
                        var zMax = Math.max(aTri.z, bTri.z, cTri.z);
                        var zMin = Math.min(aTri.z, bTri.z, cTri.z);
                        
                        var centre = new THREE.Vector3(((xMax+xMin)/2)*scale, ((yMax+yMin)/2)*scale, ((zMax+zMin)/2)*scale);
                        //scene.add( new THREE.ArrowHelper(new THREE.Vector3(0,1,0), centre, 1, 0x440088));
                        
                        //Get bounds
                        var xMaxB = Math.max(vertices[faces[i].a].x, vertices[faces[i].b].x, vertices[faces[i].c].x);
                        var xMinB = Math.min(vertices[faces[i].a].x, vertices[faces[i].b].x, vertices[faces[i].c].x);
                        var yMaxB = Math.max(vertices[faces[i].a].y, vertices[faces[i].b].y, vertices[faces[i].c].y);
                        var yMinB = Math.min(vertices[faces[i].a].y, vertices[faces[i].b].y, vertices[faces[i].c].y);
                        //Calculate size
                        sizeOfFaces.push(new THREE.Vector2((xMaxB - xMinB)*scale, (yMaxB - yMinB)*scale));
                        
                        
                        //reset vertices to orignal values
                        vertices[faces[i].a] = new THREE.Vector3(model.children[0].geometry.vertices[faces[i].a].x, 
                                                                 model.children[0].geometry.vertices[faces[i].a].y, 
                                                                 model.children[0].geometry.vertices[faces[i].a].z);
                        vertices[faces[i].b] = new THREE.Vector3(model.children[0].geometry.vertices[faces[i].b].x, 
                                                                 model.children[0].geometry.vertices[faces[i].b].y, 
                                                                 model.children[0].geometry.vertices[faces[i].b].z);
                        vertices[faces[i].c] = new THREE.Vector3(model.children[0].geometry.vertices[faces[i].c].x, 
                                                                 model.children[0].geometry.vertices[faces[i].c].y, 
                                                                 model.children[0].geometry.vertices[faces[i].c].z);
            
                        centre.applyAxisAngle(inWards, -angle);
                        centre.applyQuaternion(quaternion2);
                        
                        //scene.add( new THREE.ArrowHelper(new THREE.Vector3(0,1,0), centre, 1, 0x884400));
                        
                        ////////////////////////////////////////////////////////
                        //                   END PROBABILITY                  //
                        ////////////////////////////////////////////////////////
                       
       
                        //Calculating which pixels to cut between
                        var aCoord = new THREE.Vector2((picSize.x * model.children[0].geometry.faceVertexUvs[0][i][0].x), 
                                             picSize.y-(picSize.y * model.children[0].geometry.faceVertexUvs[0][i][0].y));
                        var bCoord = new THREE.Vector2((picSize.x * model.children[0].geometry.faceVertexUvs[0][i][1].x), 
                                             picSize.y-(picSize.y * model.children[0].geometry.faceVertexUvs[0][i][1].y));
                        var cCoord = new THREE.Vector2((picSize.x * model.children[0].geometry.faceVertexUvs[0][i][2].x), 
                                             picSize.y-(picSize.y * model.children[0].geometry.faceVertexUvs[0][i][2].y));
                        //var mCoord = new THREE.Vector2((aCoord.x+bCoord.x+cCoord.x)/3, (aCoord.y+bCoord.y+cCoord.y)/3);
                        
                        //Canvas texture stuff
                        var texXMax = Math.max(aCoord.x, bCoord.x, cCoord.x);// + padding;
                        var texYMax = Math.max(aCoord.y, bCoord.y, cCoord.y);// + padding;
                        var texXMin = Math.min(aCoord.x, bCoord.x, cCoord.x);// - padding;
                        var texYMin = Math.min(aCoord.y, bCoord.y, cCoord.y);// - padding;
                        /*
                        tempVec.copy(aCoord);
                        aCoord.add(((tempVec.sub(mCoord)).normalize()).multiplyScalar(7));
                        tempVec.copy(bCoord);
                        bCoord.add(((tempVec.sub(mCoord)).normalize()).multiplyScalar(7));
                        tempVec.copy(cCoord);
                        cCoord.add(((tempVec.sub(mCoord)).normalize()).multiplyScalar(7));
                        */
                        var canv = document.createElement("canvas");
                        canv.id = "face" + i;
                        canv.width = (texXMax-texXMin).toFixed(3);
                        canv.height = (texYMax-texYMin).toFixed(3);
                        
                        var ctx = canv.getContext("2d");
                        
                        ctx.translate(-texXMin.toFixed(3), -texYMin.toFixed(3));
                        ctx.globalAlpha = 1.00;
                        ctx.lineWidth = 1; 
                        ctx.beginPath();
                        ctx.moveTo(aCoord.x, aCoord.y);
                        ctx.lineTo(bCoord.x, bCoord.y);
                        ctx.lineTo(cCoord.x, cCoord.y);
                        
                        ctx.closePath();
                        ctx.clip();
                        ctx.drawImage(image, 0, 0);
                        
                        var element = document.createElement("img");
                        element.src = canv.toDataURL();
                        element.style.width = sizeOfFaces[i].x + 'px';
                        element.style.height = sizeOfFaces[i].y + 'px';
                        //element.style.background = new THREE.Color( Math.random() * 0xffffff ).getStyle();

                        var object = new THREE.CSS3DObject( element );
                        //.applyAxisAngle(inWards, angle);
                        var matZ = new THREE.Matrix4().makeRotationZ(-angle);
                        var mat = new THREE.Matrix4();
                        //object.rotateOnAxis(inWards, -angle);
                        object.applyMatrix(matZ);
                        object.applyMatrix(mat.makeRotationFromQuaternion(quaternion2));
                        //object.lookAt(faces[i].normal.add(object.position));
                        
                        //object.position.x = centreOfFaces[i].x;
                        //object.position.y = centreOfFaces[i].y;
                        //object.position.z = centreOfFaces[i].z;
                        
                        object.position.x = centre.x;
                        object.position.y = centre.y;
                        object.position.z = centre.z;
                        
                        scene.add( object );
                        
                        
                    }
                    
                    //renderer = new THREE.WebGLRenderer();
                    //renderer.setClearColor( 0xf0f0f0 );
                    
                    renderer = new THREE.CSS3DRenderer();
                    renderer.domElement.style.position = 'absolute';
                    renderer.domElement.style.top = 0;
                    renderer.domElement.style.left = 300;
                    renderer.setSize( winWidth, winHeight);
                    document.getElementById("p212201_ad_container").appendChild( renderer.domElement );
                    
                    animate();
                    
                };
                
                function animate() {
                    requestAnimationFrame( animate );

                    controls.update();
                    renderer.render( scene, camera );
                };
            }
                
            /**</AdScript>**/
            </script>
            <!--<AdHTML>-->
            <div id="p212201_ad_container" style="position:relative;padding:0px;margin-top:0px;margin-bottom:0px;margin-left:auto;margin-right:auto;padding-left:0px;width:320px;height:320px;background:darkgray;">
                <div id="p212201_imp_counter" style="position:absolute;z-index:0;top:0px;left:0px;width:1px;height:1px;margin:0px;padding:0px;overflow:hidden;"></div>
                <div id="p212201_display_area" style="position:absolute;top:0px;left:0px;width:320px;height:320px;margin:0px;padding:0px;-webkit-transition:all 0.5s linear 0ms;">
                    <div id="p212201_revolve_area" style="position:absolute;top:0px;left:0px;width:320px;height:320px;margin:0px;padding:0px;z-index:180;-webkit-perspective: 800;-webkit-transform-style: preserve-3d;-webkit-transform: translate3d(0px,0px,100px);">
                        <img id="p212201_img_swipe" src="http://pliing.se/img/swipe.png" style="display:block;margin:0px;padding:0px;z-index:110;position:absolute;top:120px;left:98px;width:124px;height:40px;visibility:hidden;-webkit-transform: translate3d(0px,0px,50px);" onload="loadModel();" />

                        <div  id="p212201_cube_area" onclick="p212201LoadLink();" style="margin:0px;padding:0px;z-index:100;position:absolute;top:10px;left:10px;width:300px;height:300px;-webkit-transform-style: preserve-3d;-webkit-transform: translate3d(0px,0px,-49px);">
                            <div id="p212201_rot_x" style="margin:0px;padding:0px;z-index:100;position:absolute;top:0px;left:0px;width:300px;height:300px;-webkit-transition: -webkit-transform 1.1s linear;-webkit-transform-style: preserve-3d;">
                                <div id="p212201_cube" style="margin:0px;padding:0px;z-index:100;position:absolute;top:75px;left:0px;width:300px;height:300px;-webkit-transition: -webkit-transform 0.5s ease-out;-webkit-transform-style: preserve-3d;">

                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!--</AdHTML>-->
        <!--</AdWineBox>-->
 </body>
</html>