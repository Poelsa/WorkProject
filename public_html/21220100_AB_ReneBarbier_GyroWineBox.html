<!DOCTYPE html>
 <html>
    <head>
    <!-- #ice{fullWidth} -->
    <title>Freixenet Vinbox</title>
    <meta name="viewport" content="target-densitydpi=device-dpi, width=320" />
    <style>
        html, body {
            margin:0px;
            padding:0px;
                height: 100%;
        }
        </style>
   <body style="width:320px">
            <!--<AdWineBox>-->
            <!-- Animated Ads, copyright Adssets AB, 2012 -->
            <script src="js/three.min.js"></script>
            <script src="js/CSS3DRenderer.js"></script>
            <script src="js/TrackballControls.js"></script>
            <script>
                /**<AdScript>**/
                var p212201IDLE_SPIN_INTERVAL = 4000;
                
                var P_212201_Swipe = 'http://pliing.se/PliingAd/Event?id=21220100&userAdId=**userAdId&callback=p212201Resp';
                var P_212201_NoOfImages=8;
                var p212201LoadedImages=0;
                var p212201SwipeArea;
                var p212201Cube;
                var p212201StartX=0;
                var p212201StartY=0;
                var p212201EndX=0;
                var p212201EndY=0;
                var p212201RotX;
                var p212201RotTimer;
                var p212201SpinTimer;
                var p212201RotDir=1;
                var p212201Swiped=false;
                var p212201RotAng=-360;
                var p212201Side = [];
                var p212201Script;
                var p212201isNotWebkit = navigator.userAgent.toLowerCase().indexOf("android 2.") > -1; 
                var p212201isAndroid = navigator.userAgent.toLowerCase().indexOf("android") > -1;
                var p212201ActImg;
                
                var p212201MaxGyroTilt = 25;
                
                //Added by Joel
                var model;
                
                var controls;
                var scene;
                var camera;
                var renderer;
                
                function p212201ImgLoaded () {
                    if (p212201LoadedImages==0) {
                        var node = document.getElementById("p212201_ad_container");
                        for (var i = 0; i < 4; i++) {
                            node = node.parentNode;
                            if (node == null)
                                break;
                            else if (node.className == "abAdArea") {
                                node.style.overflow = "visible";
                                node.style.display = "block";
                                break;
                            }
                        }
                        if (p212201isNotWebkit) {
                            document.getElementById("p212201_img_swipe").style.webkitTransform="translate3d(0px,0px,0px)";
                            document.getElementById("p212201_cube_area").style.webkitTransform="translate3d(0px,0px,0px)";
                            document.getElementById("p212201_cube_area").style.overflow="hidden";
                            for (var i=0;i<4;i++) {
                                p212201Side[i] = document.getElementById("p212201_side_"+(i+1));
                                if (i==0)
                                    p212201Side[i].style.opacity="1.0";
                                else
                                    p212201Side[i].style.opacity="0.0";
                                if (i==3)
                                    p212201Side[i].style.webkitTransform="translate3d(-300px,0px,0px)";
                                else
                                    p212201Side[i].style.webkitTransform="translate3d("+(300*i)+"px,0px,0px)";
                            }
                        }
                    }
                    p212201LoadedImages++;
                    if (p212201LoadedImages == (P_212201_NoOfImages)) {
                        p212201InitBanner();
                    }
                }
                function p212201InitBanner () {
                    if (p212201isNotWebkit) {
                        window.scrollBy(0,1);
                        for (var i=0;i<4;i++)
                            p212201Side[i].style.webkitTransition="all 0.5s ease-out";
                    }
                    
                    p212201SwipeArea = document.getElementById("p212201_revolve_area");
                    p212201Cube = document.getElementById("p212201_cube");
                    p212201RotX = document.getElementById("p212201_rot_x");
                    p212201AddListener();
                    p212201Rotate();
                    document.getElementById("p212201_img_swipe").style.visibility="visible";
                }
                function p212201Rotate () {
                    
                    p212201ActImg = 4;
                    
                    
                    if (p212201isNotWebkit) {
                        p212201ARot(1);
                        window.setTimeout(function () {p212201ARot(1)}, 400);
                        window.setTimeout(function () {p212201ARot(1)}, 800);
                        window.setTimeout(function () {p212201ARot(1)}, 1200);
                    }
                    else {
                        p212201RotAng=p212201ActImg*(-90);               
                        p212201Cube.style.webkitTransform="rotateY("+p212201RotAng+"deg)";
                        p212201RotX.style.webkitTransform="rotateX(-12deg)";
                    }
                }
                function p212201ARot (rot) {
                    var i = (p212201ActImg+rot)%4;
                    p212201ActImg = i;
                    p212201Side[i].style.opacity="1.0";
                    p212201Side[i].style.webkitTransform="translate(0px,0px)";
                    p212201Side[(i+1)%4].style.opacity="0.0";
                    p212201Side[(i+1)%4].style.webkitTransform="translate(300px,0px)";
                    p212201Side[(i+2)%4].style.opacity="0.0";
                    p212201Side[(i+2)%4].style.webkitTransform="translate(600px,0px)";
                    p212201Side[(i+3)%4].style.opacity="0.0";
                    p212201Side[(i+3)%4].style.webkitTransform="translate(-300px,0px)";
                }
                function p212201IdleRot(){
                    p212201RotDir=(p212201RotDir+1)%4;
                    var i,j;
                    switch (p212201RotDir) {
                        case 0:
                            i=0;j=1;break;
                        case 1:
                            i=-1;j=0;break;
                        case 2:
                            i=0;j=-1;break;
                        case 3:
                            i=1;j=0;break;
                    }
                    p212201RotX.style.webkitTransform="rotateX("+(i*15)+"deg) rotateY("+(j*15)+"deg)";
                }
                
                function p212201IdleSpin(){
                    p212201RotAng=(p212201RotAng + 180);
                    p212201RotAng =(Math.floor(p212201RotAng/180) * 180);
                    p212201Cube.style.webkitTransform="rotateY("+p212201RotAng+"deg)";
                }
                
                function p212201AddListener()
                {
                    p212201SwipeArea.addEventListener("touchstart", p212201TouchStart, false);
                    p212201SwipeArea.addEventListener("touchmove", p212201TouchMove, false);
                    p212201SwipeArea.addEventListener("touchend", p212201TouchEnd, false);
                    if (window.DeviceOrientationEvent){
                        window.addEventListener("deviceorientation", p212201DeviceOrientationHandler, false);
                    }
                }
                function p212201RemoveListener(e)
                {
                    e.removeEventListener("touchstart", p212201TouchStart, false);
                    e.removeEventListener("touchmove", p212201TouchMove, false);
                    e.removeEventListener("touchend", p212201TouchEnd, false);
                }
                function p212201TouchStart(e)
                {
                    p212201StartX = e.touches[0].pageX;
                    p212201StartY = e.touches[0].pageY;
                    p212201EndX = 0;
                    p212201EndY = 0;
                    if (window.DeviceOrientationEvent){
                        window.removeEventListener("deviceorientation", p212201DeviceOrientationHandler, false);
                    }
                } 
                function p212201TouchMove(e)
                {
                    if (Math.abs(e.touches[0].pageX - p212201StartX) > Math.abs(e.touches[0].pageY - p212201StartY)) {
                        e.preventDefault();
                        p212201EndX = e.touches[0].pageX - p212201StartX;
                        p212201EndY = p212201StartY - e.touches[0].pageY;
                        if (p212201isNotWebkit) {
                            var i = p212201ActImg;
                            p212201Side[i].style.opacity=1-(Math.abs(p212201EndX)/300);
                            p212201Side[i].style.webkitTransform="translate("+p212201EndX+"px,0px)";
                            if (p212201EndX > 0) {
                                p212201Side[(i+3)%4].style.opacity=p212201EndX/300;
                                p212201Side[(i+3)%4].style.webkitTransform="translate("+(p212201EndX-300)+"px,0px)";
                            }
                            else {
                                p212201Side[(i+1)%4].style.opacity=Math.abs(p212201EndX)/300;
                                p212201Side[(i+1)%4].style.webkitTransform="translate("+(300+p212201EndX)+"px,0px)";
                            }
                        }
                        else {
                            p212201Cube.style.webkitTransform="rotateY("+(p212201RotAng+p212201EndX)+"deg)";
                            p212201RotX.style.webkitTransform="rotateX("+p212201EndY+"deg)";
                        }
                    }
                }
                
                function p212201TouchEnd(e)
                {
                    var next=0;
                    if (Math.abs(p212201EndX)>45) {
                        document.getElementById("p212201_img_swipe").style.visibility="hidden";
                        document.getElementById("p212201_img_swipe").style.webkitTransform="translate3d(0px,0px,-150px)";
                        p212201RegSwipe ();
                        if (p212201isNotWebkit) {
                            if (p212201EndX>0) 
                                next=3;
                            else
                                next=1;
                        }
                        else {
                            if (p212201EndX>=0) 
                                p212201RotAng=(p212201RotAng + (90 * Math.round((p212201EndX/90))));
                            else if (p212201EndX<0)
                                p212201RotAng=(p212201RotAng + (90 * Math.round((p212201EndX/90))));
                        }
                    }
                    if (p212201isNotWebkit)
                        p212201ARot(next);
                    else {
                        p212201Cube.style.webkitTransform="rotateY("+p212201RotAng+"deg)";
                    }
                    
                    if (window.DeviceOrientationEvent){
                        window.addEventListener("deviceorientation", p212201DeviceOrientationHandler, false);
                    }
                }
                function p212201RegSwipe () {
                    if (!p212201Swiped) {
                        p212201Swiped=true;
                        p212201RegEvent (P_212201_Swipe);
                    }
                }
                function p212201RegEvent (src) {
                    p212201Script= document.createElement('script');
                    p212201Script.type= 'text/javascript';
                    p212201Script.src= src;
                    document.getElementsByTagName('head')[0].appendChild(p212201Script);
                }
                function p212201Resp(xmlData) {
                    document.getElementsByTagName('head')[0].removeChild(p212201Script);
                }
                
                function p212201LoadIcal(){
                    window.open("http://pliing.se/img12/box/new/boxvinnew.ics", "_parent");
                    p212201RegEvent(P_212201_iCal);
                }
                
                function p212201LoadLink(){
                    window.open("http://pliing.se/PliingAd/ExtLink?id=21220110&userAdId=**userAdId","_blank");
                }
                
                function p212201DeviceOrientationHandler(gyroData){
                    var p212201Alpha = gyroData.alpha;
                    var p212201Beta = gyroData.beta;
                    var p212201Gamma = gyroData.gamma;
                    if(typeof p212201OAlpha === 'undefined'){
                        p212201OAlpha = p212201Alpha;
                        p212201OBeta = p212201Beta;
                        p212201OGamma = p212201Gamma;
                    }
                    
                    var gyroAngX, gyroAngY;
                    if(p212201Gamma >= 90){
                        gyroAngX = p212201CorrectInterval(p212201OBeta + (90 - p212201Beta), p212201MaxGyroTilt);
                        gyroAngY = (p212201RotAng + p212201CorrectInterval((180 - p212201Gamma - p212201OGamma), p212201MaxGyroTilt));
                    } else {
                        gyroAngX = p212201CorrectInterval((p212201Beta - p212201OBeta), p212201MaxGyroTilt); 
                        gyroAngY = (p212201RotAng - p212201CorrectInterval((p212201Gamma - p212201OGamma), p212201MaxGyroTilt));
                    }
                    p212201Cube.style.webkitTransform = "rotateY(" + gyroAngY + "deg)"; 
                    p212201RotX.style.webkitTransform = "rotateX(" + gyroAngX + "deg) ";
                }
                
                function p212201CorrectInterval(val, max){
                    if(val > max){
                        val = max;
                    } else if(val < -max){
                        val = -max;
                    }
                    return val;
                }
                
                //Model loader stuff
                function loadModel() {
                    var jsonLoader = new THREE.JSONLoader();
                    jsonLoader.load("/WineBottleProject/Model/Vinflaska/lowpolyG.json", modelLoaded);
                    //jsonLoader.load("/WineBottleProject/Model/Vinflaska/flaska.json", modelLoaded);
                }
                
                var modelLoaded = function(geometry, materials) {
                    var material = new THREE.MeshFaceMaterial(materials);
                    model = new THREE.Mesh(geometry, material);
                    //model = new THREE.Mesh(new THREE.TetrahedronGeometry(7), material);
                    //model = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), material);
                    convertModel();
                };
                
                function convertModel() {
                    
                    //////////// TEST /////////////////
                    
                    scene = new THREE.Scene();
                    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
                    camera.position.set( 0, 500, 900 );
                    
                    controls = new THREE.TrackballControls( camera );
                    
                    /////////////////////////////////
                    
                    var faces = model.geometry.faces;
                    
                    var loopLength = faces.length;
                    var scale = 100;
                    var offsetY = 400;
                    
                    var padding = 0;
                    
                    var flipY = 1;
                    var flipZ = 1;
                    
                    var rotation = new THREE.Euler(Math.PI, 0, 0, "XYZ");
                    var rotateEuler = false;
                    
                    var vertices = [];
                    for (var i = 0; i < model.geometry.vertices.length; i++) {
                        //Copying value instead of reference to not change original values later
                        vertices[i] = new THREE.Vector3(model.geometry.vertices[i].x, flipY*model.geometry.vertices[i].y, flipZ*model.geometry.vertices[i].z);
                        if(rotateEuler)
                            vertices[i].applyEuler(rotation);
                    }
                    
                    var centreOfFaces = [];
                    var centre;
                    var aTri, bTri, cTri;
                    
                    var rotationOfFaces = [];
                    var quaternion = new THREE.Quaternion();
                    var quaternion2 = new THREE.Quaternion();
                    var sizeOfFaces = [];
                    
                    var aCoord = new THREE.Vector2(), bCoord = new THREE.Vector2(), cCoord = new THREE.Vector2();
                    var width = 300;
                    var height = 300;
                    
                    var tempVec = new THREE.Vector2();
                    
                    var image = new Image();
                    image.src = "/WineBottleProject/Model/Vinflaska/vinflaska_textur.jpg";
                    
                    image.onload = function() {
                    for (var i = 0; i < loopLength; i++) {
                        var picSize = new THREE.Vector2(image.width, image.height);
                        if(rotateEuler)
                            faces[i].normal.applyEuler(rotation);
                        
                        aTri = new THREE.Vector3(vertices[faces[i].a].x, vertices[faces[i].a].y, vertices[faces[i].a].z);
                        bTri = new THREE.Vector3(vertices[faces[i].b].x, vertices[faces[i].b].y, vertices[faces[i].b].z);
                        cTri = new THREE.Vector3(vertices[faces[i].c].x, vertices[faces[i].c].y, vertices[faces[i].c].z);
                        //This calculates the centre of the triangle face
                        //centre = (aTri.add(bTri.add(cTri))).divideScalar(3);
                        
                        //This calculates the centre of the triangles bounding box
                        var xMax = Math.max(aTri.x, bTri.x, cTri.x);
                        var xMin = Math.min(aTri.x, bTri.x, cTri.x);
                        var yMax = Math.max(aTri.y, bTri.y, cTri.y);
                        var yMin = Math.min(aTri.y, bTri.y, cTri.y);
                        var zMax = Math.max(aTri.z, bTri.z, cTri.z);
                        var zMin = Math.min(aTri.z, bTri.z, cTri.z);
                        
                        centre = new THREE.Vector3(((xMax+xMin)/2)*scale, ((yMax+yMin)/2)*scale, ((zMax+zMin)/2)*scale);
                        centreOfFaces.push(centre);
                    }
                    
                    //for (var i = 0; i < model.geometry.vertices.length; i++) {
                    //    vertices[i].applyEuler(rotation);
                    //}
                    var norm, tempNorm, planeNorm;
                    var angleX, angleY, angleZ;
                    var quats = [];
                    for (var i = 0; i < loopLength; i++) {
                        // Getting rotation of all faces
                    
                        norm = new THREE.Vector3(faces[i].normal.x, flipY*faces[i].normal.y, flipZ*faces[i].normal.z);
                        //norm.normalize();
                        var tepm = new THREE.Vector3(0,0,1);
                        quaternion = quaternion.setFromUnitVectors(norm, tepm);
                        quats.push(quaternion2.setFromUnitVectors(tepm, norm));
                        //quaternion = quats[i];
                        rotationOfFaces.push(new THREE.Euler());
                        rotationOfFaces[i].setFromQuaternion(quaternion, "XYZ");
                        tepm.applyQuaternion(quats[i]);
                        //console.log("Normal: X: " + norm.x + ", Y: " + norm.y , ", Z: " + norm.z);
                        //console.log("tepm + quat: X: " + tepm.x + ", Y: " + tepm.y , ", Z: " + tepm.z);
                        
                        //norm = new THREE.Vector3(faces[i].normal.x, flipY*faces[i].normal.y, flipZ*faces[i].normal.z);
                        //Angle around the X axis
                        /*tempNorm = new THREE.Vector3(0, norm.y, norm.z);
                        planeNorm = new THREE.Vector3(0,0,1); //Z-positive or Z-negative??
                        angleX = tempNorm.angleTo(planeNorm); //Get angle to the plane
                        //Angle around the Y axis
                        tempNorm = new THREE.Vector3(norm.x, 0, norm.z);
                        planeNorm = new THREE.Vector3(0,0,1);
                        angleY = tempNorm.angleTo(planeNorm);
                        //Angle around the Z axis
                        tempNorm = new THREE.Vector3(norm.x, norm.y, 0);
                        planeNorm = new THREE.Vector3(1,0,0);
                        angleZ = tempNorm.angleTo(planeNorm);
                        
                        rotationOfFaces.push(new THREE.Euler(angleX, angleY, angleZ, "XYZ"));*/
                        
                        
                        // Calculating size of faces
                        //Rotate the face to get a uniform starting point
                        //console.log("Before: X: " + vertices[faces[i].a].x + ", Y: " + vertices[faces[i].a].y , ", Z: " + vertices[faces[i].a].z);
                        vertices[faces[i].a].applyEuler(rotationOfFaces[i]);
                        vertices[faces[i].b].applyEuler(rotationOfFaces[i]);
                        vertices[faces[i].c].applyEuler(rotationOfFaces[i]);
                        
                        //Get bounds
                        var xMaxB = Math.max(vertices[faces[i].a].x, vertices[faces[i].b].x, vertices[faces[i].c].x);
                        var xMinB = Math.min(vertices[faces[i].a].x, vertices[faces[i].b].x, vertices[faces[i].c].x);
                        var yMaxB = Math.max(vertices[faces[i].a].y, vertices[faces[i].b].y, vertices[faces[i].c].y);
                        var yMinB = Math.min(vertices[faces[i].a].y, vertices[faces[i].b].y, vertices[faces[i].c].y);
                        //Calculate size
                        sizeOfFaces.push(new THREE.Vector2((xMaxB - xMinB)*scale, (yMaxB - yMinB)*scale));
                        //reset vertices to orignal values
                        vertices[faces[i].a] = new THREE.Vector3(model.geometry.vertices[faces[i].a].x, flipY*model.geometry.vertices[faces[i].a].y, flipZ*model.geometry.vertices[faces[i].a].z);
                        vertices[faces[i].b] = new THREE.Vector3(model.geometry.vertices[faces[i].b].x, flipY*model.geometry.vertices[faces[i].b].y, flipZ*model.geometry.vertices[faces[i].b].z);
                        vertices[faces[i].c] = new THREE.Vector3(model.geometry.vertices[faces[i].c].x, flipY*model.geometry.vertices[faces[i].c].y, flipZ*model.geometry.vertices[faces[i].c].z);
                        if(rotateEuler)
                        {
                            vertices[faces[i].a].applyEuler(rotation);
                            vertices[faces[i].b].applyEuler(rotation);
                            vertices[faces[i].c].applyEuler(rotation);
                        }
                        //console.log("After: X: " + vertices[faces[i].a].x + ", Y: " + vertices[faces[i].a].y , ", Z: " + vertices[faces[i].a].z);
                        //Convert to web coord system
                        //centreOfFaces[i].applyEuler(rotation);
                        //centreOfFaces[i].y *= -1;
                        
                        
                        // Adding img elements to html code
                    
                        //Calculating which pixels to cut between
                        aCoord = new THREE.Vector2((picSize.x * model.geometry.faceVertexUvs[0][i][0].x), picSize.y-(picSize.y * model.geometry.faceVertexUvs[0][i][0].y));
                        bCoord = new THREE.Vector2((picSize.x * model.geometry.faceVertexUvs[0][i][1].x), picSize.y-(picSize.y * model.geometry.faceVertexUvs[0][i][1].y));
                        cCoord = new THREE.Vector2((picSize.x * model.geometry.faceVertexUvs[0][i][2].x), picSize.y-(picSize.y * model.geometry.faceVertexUvs[0][i][2].y));
                        var mCoord = new THREE.Vector2((aCoord.x+bCoord.x+cCoord.x)/3, (aCoord.y+bCoord.y+cCoord.y)/3)
                        
                        //Canvas texture stuff
                        var texXMax = Math.max(aCoord.x, bCoord.x, cCoord.x) + padding;
                        var texYMax = Math.max(aCoord.y, bCoord.y, cCoord.y) + padding;
                        var texXMin = Math.min(aCoord.x, bCoord.x, cCoord.x) - padding;
                        var texYMin = Math.min(aCoord.y, bCoord.y, cCoord.y) - padding;
                        
                        tempVec.copy(aCoord);
                        aCoord.add(((tempVec.sub(mCoord)).normalize()).multiplyScalar(7));
                        tempVec.copy(bCoord);
                        bCoord.add(((tempVec.sub(mCoord)).normalize()).multiplyScalar(7));
                        tempVec.copy(cCoord);
                        cCoord.add(((tempVec.sub(mCoord)).normalize()).multiplyScalar(7));
                        
                        var canv = document.createElement("canvas");
                        canv.id = "face" + i;
                        canv.width = (texXMax-texXMin).toFixed(3);
                        canv.height = (texYMax-texYMin).toFixed(3);
                        
                        var ctx = canv.getContext("2d");
                        
                        ctx.translate(-texXMin.toFixed(3), -texYMin.toFixed(3));
                        ctx.globalAlpha = 1.00;
                        ctx.lineWidth = 1; 
                        ctx.beginPath();
                        ctx.moveTo(aCoord.x, aCoord.y);
                        ctx.lineTo(bCoord.x, bCoord.y);
                        ctx.lineTo(cCoord.x, cCoord.y);
                        
                        ctx.closePath();
                        ctx.clip();
                        ctx.drawImage(image, 0, 0);
                        
                        //////////////////////////////////////////////////////////////
                        
                        ////////////THIS IS THE THREE.JS CSSRENDERER TEST/////////////
                        
                        //////////////////////////////////////////////////////////////
                        
                        
                        
                        var element = document.createElement("img");
                        element.src = canv.toDataURL();
                        element.style.width = sizeOfFaces[i].x + 'px';
                        element.style.height = sizeOfFaces[i].y + 'px';
                        //element.style.background = new THREE.Color( Math.random() * 0xffffff ).getStyle();

                        var object = new THREE.CSS3DObject( element );
                        
                        
                        object.up = new THREE.Vector3(0,1,0);
                        //object.useQuaternion = true;
                        //object.rotation.x = 0;
                        //object.rotation.y = 0;
                        //object.rotation.z = 0;
                        //object.quaternion = quats[i];
                        //console.log("quat: " + quats[i].x + ", " + quats[i].y + ", " + quats[i].z + ", " + quats[i].w);
                        var mat = new THREE.Matrix4();
                        object.applyMatrix(mat.makeRotationFromQuaternion(quats[i]));
                        //object.lookAt(faces[i].normal.add(object.position));
                        
                        object.position.x = centreOfFaces[i].x;
                        object.position.y = centreOfFaces[i].y;
                        object.position.z = centreOfFaces[i].z;
                        
                        //object.rotation.x = -rotationOfFaces[i].x;
                        //object.rotation.y = -rotationOfFaces[i].y;
                        //object.rotation.z = -rotationOfFaces[i].z;
                        scene.add( object );
                        
                        
                        
                        ///////////////////////END OF TEST////////////////////////////
                        /*
                        var img = document.createElement("img");
                        img.src = canv.toDataURL();
                        //Set attributes
                        //Width & height
                        img.setAttribute("width", sizeOfFaces[i].x.toFixed(3));
                        img.setAttribute("height", sizeOfFaces[i].y.toFixed(3));
                        //Position & rotation
                        img.style.position = "absolute";
                        //The following is to set the topleft corner, we will move the img with translate3d after
                        img.style.top = (height/2 - (sizeOfFaces[i].y/2) - padding).toFixed(3) + "px"; 
                        img.style.left = (width/2 - (sizeOfFaces[i].x/2) - padding).toFixed(3) + "px";
                        
                        //Maybe haxx something with rotate3d(x, y, z) (setting a point from which to rotate around)
                        //Nope...
                        
                        var yPos = offsetY + centreOfFaces[i].y;
                        //var yRot = new THREE.Vector3(faces[i].normal.x, faces[i].normal.y, faces[i].normal.z);
                        var yRot = new THREE.Vector3(0,0,1);
                        var yEul = new THREE.Euler(-rotationOfFaces[i].x + Math.PI/2,0,0,"XYZ");
                        //yRot.applyEuler(new THREE.Euler(0,Math.PI/2,0,"XYZ"));
                        yRot.applyEuler(yEul);
                        
                        img.style.webkitTransform = "translate3d(" + centreOfFaces[i].x.toFixed(3) + "px, " + yPos.toFixed(3) + "px, " + centreOfFaces[i].z.toFixed(3) + "px) " + 
                                "rotateX(" + (-rotationOfFaces[i].x) + "rad)" +
                                "rotateY(" + (-rotationOfFaces[i].y) + "rad)" +
                                "rotateZ(" + (-rotationOfFaces[i].z) + "rad)";
                                //"rotate3D("+(yRot.x)+", "+(-yRot.y)+", "+(-yRot.z)+"," + (-rotationOfFaces[i].y) + "rad)" +
                                //"rotate3D("+(faces[i].normal.x)+", "+(-faces[i].normal.y)+", "+(-faces[i].normal.z)+"," + (-rotationOfFaces[i].z) + "rad)";
                        
                        //Other
                        img.style.webkitTransformStyle =  "preserve-3d";
                        img.setAttribute("z-index", 100+i);
                        img.setAttribute("margin", "0");
                        img.setAttribute("padding", "0");
                        //add to id="p212201_cube" 
                        document.getElementById("p212201_cube").appendChild(img);
                        
                        ////////DEBUG//////////
                        
                        var dummyNorm = new THREE.Vector3(0,0,1);
                        dummyNorm.applyEuler(new THREE.Euler(-rotationOfFaces[i].x,0,0,"XYZ"));
                        dummyNorm.applyEuler(new THREE.Euler(0,-rotationOfFaces[i].y,0,"XYZ"));
                        dummyNorm.applyEuler(new THREE.Euler(0,0,-rotationOfFaces[i].z,"XYZ"));
                        
                        var st = window.getComputedStyle(img, null);
                        var matrix = new WebKitCSSMatrix(st.getPropertyValue("-webkit-transform"));
                        
                        var tempRot = new THREE.Vector3(0,0,1);
                        tempRot.applyEuler(rotationOfFaces[i]);
                        console.log("THIS IS NUMBER " + i);
                        console.log("Normal: X: " + norm.x + ", Y: " + norm.y , ", Z: " + norm.z);
                        console.log("Angles: X:" + rotationOfFaces[i].x + ", Y: " + rotationOfFaces[i].y , ", Z: " + rotationOfFaces[i].z);
                        console.log("Rotation applied: X: " + tempRot.x + ", Y: " + tempRot.y , ", Z: " + tempRot.z);
                        console.log("DummyNorm: X: " + dummyNorm.x + ", Y: " + dummyNorm.y , ", Z: " + dummyNorm.z);
                        console.log("Matrix stuff X: " + Math.acos(matrix.a));
                        console.log("Matrix stuff Y: " + Math.acos(matrix.b));
                        console.log("Matrix stuff Z: " + Math.acos(matrix.c));
                        //console.log("yRot: X: " + yRot.x + ", Y: " + yRot.y , ", Z: " + yRot.z);
                        console.log("--------------------------------------");
                        /////////////////////////////
                        
                        */
                        
                    }
                    
                    ///////// TEST THREEJS CSS STUFF //////////////
                    renderer = new THREE.CSS3DRenderer();
                    renderer.setSize( 1000, 500 );
                    renderer.domElement.style.position = 'absolute';
                    renderer.domElement.style.top = 0;
                    document.getElementById("p212201_ad_container").appendChild( renderer.domElement );
                    
                    animate();
                    
                };
                
                function animate() {
                    requestAnimationFrame( animate );

                    controls.update();
                    renderer.render( scene, camera );
                };
            }
                
            /**</AdScript>**/
            </script>
            <!--<AdHTML>-->
            <div id="p212201_ad_container" style="position:relative;padding:0px;margin-top:0px;margin-bottom:0px;margin-left:auto;margin-right:auto;padding-left:0px;width:320px;height:320px;background:darkgray;">
                <div id="p212201_imp_counter" style="position:absolute;z-index:0;top:0px;left:0px;width:1px;height:1px;margin:0px;padding:0px;overflow:hidden;"></div>
                <div id="p212201_display_area" style="position:absolute;top:0px;left:0px;width:320px;height:320px;margin:0px;padding:0px;-webkit-transition:all 0.5s linear 0ms;">
                    <div id="p212201_revolve_area" style="position:absolute;top:0px;left:0px;width:320px;height:320px;margin:0px;padding:0px;z-index:180;-webkit-perspective: 800;-webkit-transform-style: preserve-3d;-webkit-transform: translate3d(0px,0px,100px);">
                        <img id="p212201_img_swipe" src="http://pliing.se/img/swipe.png" style="display:block;margin:0px;padding:0px;z-index:110;position:absolute;top:120px;left:98px;width:124px;height:40px;visibility:hidden;-webkit-transform: translate3d(0px,0px,50px);" onload="p212201InitBanner();" />

                        <div  id="p212201_cube_area" onclick="p212201LoadLink();" style="margin:0px;padding:0px;z-index:100;position:absolute;top:10px;left:10px;width:300px;height:300px;-webkit-transform-style: preserve-3d;-webkit-transform: translate3d(0px,0px,-49px);">
                            <div id="p212201_rot_x" style="margin:0px;padding:0px;z-index:100;position:absolute;top:0px;left:0px;width:300px;height:300px;-webkit-transition: -webkit-transform 1.1s linear;-webkit-transform-style: preserve-3d;">
                                <div id="p212201_cube" style="margin:0px;padding:0px;z-index:100;position:absolute;top:75px;left:0px;width:300px;height:300px;-webkit-transition: -webkit-transform 0.5s ease-out;-webkit-transform-style: preserve-3d;">

                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="p212201_bg_area" style="">
                        <img id="p212201_img_background" src="http://pliing.se/img31/freixenet/bakgrund.png" style="display:block;margin:0px;padding:0px;z-index:0;position:absolute;top:0px;left:0px;width:320px;height:320px;" onload="loadModel();" />
                    </div>
                </div>
            </div>
            <!--</AdHTML>-->
        <!--</AdWineBox>-->
 </body>
</html>